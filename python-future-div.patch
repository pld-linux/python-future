From 8209539e0f4c20c47ce455957c7b2f00bad30b69 Mon Sep 17 00:00:00 2001
From: Jordan Adler <jadler@pinterest.com>
Date: Fri, 13 Jul 2018 15:46:29 -0700
Subject: [PATCH 1/3] Skip float divisions in fix_division_safe

---
 src/libfuturize/fixes/fix_division_safe.py | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/src/libfuturize/fixes/fix_division_safe.py b/src/libfuturize/fixes/fix_division_safe.py
index 5e16b0a..5cdd626 100644
--- a/src/libfuturize/fixes/fix_division_safe.py
+++ b/src/libfuturize/fixes/fix_division_safe.py
@@ -13,6 +13,9 @@
 nothing.
 """
 
+import re
+import lib2to3.pytree as pytree
+from lib2to3.fixer_util import Leaf, Node
 from lib2to3 import fixer_base
 from lib2to3.fixer_util import syms, does_tree_import
 from libfuturize.fixer_util import (token, future_import, touch_import_top,
@@ -28,6 +31,18 @@ def match_division(node):
     return node.type == slash and not node.next_sibling.type == slash and \
                                   not node.prev_sibling.type == slash
 
+const_re = re.compile('^[0-9.]+$')
+
+
+def _is_floaty(expr):
+    if isinstance(expr, Leaf):
+        # If it's a leaf, let's see if it's a numeric constant containing a '.'
+        return const_re.match(expr.value)
+    elif isinstance(expr, Node):
+        # If the expression is a node, let's see if it's a direct cast to float
+        return expr.children[0].value == u'float'
+    return False
+
 
 class FixDivisionSafe(fixer_base.BaseFix):
     # BM_compatible = True
@@ -68,5 +83,10 @@ def transform(self, node, results):
         expr1, expr2 = results[0].clone(), results[1].clone()
         # Strip any leading space for the first number:
         expr1.prefix = u''
+        # if expr1 or expr2 are obviously floats, we don't need to wrap in
+        # old_div, as the behavior of division between any number and a float
+        # should be the same in 2 or 3
+        if _is_floaty(expr1) or _is_floaty(expr2):
+            return
         return wrap_in_fn_call("old_div", (expr1, expr2), prefix=node.prefix)
 

From 03770dbc4494433fa711c9a4b4bce091efa0c6e9 Mon Sep 17 00:00:00 2001
From: Jordan Adler <jadler@pinterest.com>
Date: Fri, 3 Aug 2018 15:35:01 -0700
Subject: [PATCH 2/3] bugfix

---
 src/libfuturize/fixes/fix_division_safe.py | 2 +-
 tests/test_future/test_futurize.py         | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/libfuturize/fixes/fix_division_safe.py b/src/libfuturize/fixes/fix_division_safe.py
index 5cdd626..a2ef098 100644
--- a/src/libfuturize/fixes/fix_division_safe.py
+++ b/src/libfuturize/fixes/fix_division_safe.py
@@ -31,7 +31,7 @@ def match_division(node):
     return node.type == slash and not node.next_sibling.type == slash and \
                                   not node.prev_sibling.type == slash
 
-const_re = re.compile('^[0-9.]+$')
+const_re = re.compile('^[0-9]*[.][0-9]*$')
 
 
 def _is_floaty(expr):
diff --git a/tests/test_future/test_futurize.py b/tests/test_future/test_futurize.py
index f3fe0b8..5943f8a 100644
--- a/tests/test_future/test_futurize.py
+++ b/tests/test_future/test_futurize.py
@@ -1179,7 +1179,7 @@ def test_safe_division(self):
         from __future__ import division
         from past.utils import old_div
         x = old_div(3, 2)
-        y = old_div(3., 2)
+        y = 3. / 2
         assert x == 1 and isinstance(x, int)
         assert y == 1.5 and isinstance(y, float)
         """

From ef625b060ebef20f50999f319b466789d50df295 Mon Sep 17 00:00:00 2001
From: Jordan Adler <jadler@pinterest.com>
Date: Wed, 8 Aug 2018 14:44:43 -0700
Subject: [PATCH 3/3] Only import past.utils.old_div() if needed; Verify the
 expression isnt a nested expression when doing a floaty check

---
 src/libfuturize/fixes/fix_division_safe.py | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/libfuturize/fixes/fix_division_safe.py b/src/libfuturize/fixes/fix_division_safe.py
index a2ef098..3a0d9ae 100644
--- a/src/libfuturize/fixes/fix_division_safe.py
+++ b/src/libfuturize/fixes/fix_division_safe.py
@@ -40,7 +40,8 @@ def _is_floaty(expr):
         return const_re.match(expr.value)
     elif isinstance(expr, Node):
         # If the expression is a node, let's see if it's a direct cast to float
-        return expr.children[0].value == u'float'
+        if isinstance(expr.children[0], Leaf):
+            return expr.children[0].value == u'float'
     return False
 
 
@@ -79,7 +80,6 @@ def transform(self, node, results):
             return
         future_import(u"division", node)
 
-        touch_import_top(u'past.utils', u'old_div', node)
         expr1, expr2 = results[0].clone(), results[1].clone()
         # Strip any leading space for the first number:
         expr1.prefix = u''
@@ -88,5 +88,6 @@ def transform(self, node, results):
         # should be the same in 2 or 3
         if _is_floaty(expr1) or _is_floaty(expr2):
             return
+        touch_import_top(u'past.utils', u'old_div', node)
         return wrap_in_fn_call("old_div", (expr1, expr2), prefix=node.prefix)
 
